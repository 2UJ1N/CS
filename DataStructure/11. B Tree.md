## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## B Tree

이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리

➡️ 최대 M개의 자식을 가질 수있는 B-Tree → **M차** B-Tree

![49](https://github.com/2UJ1N/CS/assets/83401978/8dff2b5d-6efb-4aa6-b172-7e1e3f7c56fb)

- 특징
    - 하나의 노드에 여러 자료를 배치할 수 있음
        
        ➡️ 이진 트리보다 훨씬 많은 데이터를 효율적으로 저장소에 담을 수 있다
        
        (하드디스크, SSD 등의 외부 기억 장치는 블럭 단위로 파일을 입출력한다. 이때 발생하는 입출력 비용이 파일 크기와 상관없이 동일하기 때문에 
        → 하나의 블럭에 여러 데이터들을 동시에 저장해 블럭을 보다 효율적으로 사용할 수 있다)
        
    - 노드에는 2개 이상의 데이터 Key가 들어갈 수 있으며, 항상 **정렬**된 상태이다
        
        ![50](https://github.com/2UJ1N/CS/assets/83401978/8ea7d9a3-4123-457f-b265-849f6b66a7df)
        
    - 내부 노드는 ceil(M/2) ~ M개의 자식을 가질 수 있다
    ➡️ 최대 M개의 자식을 가질 수있는 B-Tree → **M차** B-Tree
        
        ![51](https://github.com/2UJ1N/CS/assets/83401978/375ffc49-5552-4155-8bc4-0ba6ed1fab61)
        
    - 특정 노드의 데이터가 K개 → 자식 노드의 개수는 K+1개
        
        ![52](https://github.com/2UJ1N/CS/assets/83401978/6ff4f4aa-61d9-4edf-b8b5-494f70420822)
        
    - 특정 노드의 왼쪽 서브트리는 특정 노드 key보다 작은 값, 오른쪽 서브트리는 큰 값으로 구성
        
        ![53](https://github.com/2UJ1N/CS/assets/83401978/406cd191-2818-4232-897f-7c1190da46ef)
        
    - 노드 내에 데이터는 ceil(M/2) - 1개 ~ M-1개까지 포함 가능하다
        
        ![54](https://github.com/2UJ1N/CS/assets/83401978/570e46f0-f53f-4310-b395-92966361928b)
        
    - 모든 리프 노드들이 같은 레벨에 존재
        
        ![55](https://github.com/2UJ1N/CS/assets/83401978/4cab2306-0da6-4b3e-b96d-c92b88921e57)
        
- 동작 과정
    - **탐색**
        
        루트 노드부터 **하향식**으로 탐색
        
        1️⃣ 루트 노드에서 탐색 시작
        
        2️⃣ target(=K)을 찾았다면 탐색 종료
        
        3️⃣ K과 key값을 비교해 알맞은 자식 노드로 내려간다
        
        4️⃣ 해당 과정을 리프 노드에 도달할 때까지 반복
        
        5️⃣ 리프 노드에서도 K을 찾지 못한다면 트리에 값 존재X

      - 탐색 과정1 - 루트 노드에서 K와 key값을 비교
        ![56](https://github.com/2UJ1N/CS/assets/83401978/39f97be3-e127-446a-a78f-d1c9364e1682)
        
      - 탐색 과정2 - 비교 결과 10~21 사이의 값이기 때문에 가운데 자식 포인터를 타고 내려감
        ![57](https://github.com/2UJ1N/CS/assets/83401978/9e66499e-3916-4e50-8489-7cee3230ad43)
     
      - 탐색 과정3 - 동일하게 K와 key값을 비교
        ![58](https://github.com/2UJ1N/CS/assets/83401978/705215a2-92f2-49f9-a0d2-03a64516b3fb)
        
      - 탐색 과정4 - 비교 결과 가운데 포인터로 내려가 리프노드에서 해당 값 탐색 성공
        ![59](https://github.com/2UJ1N/CS/assets/83401978/8d0699fd-4412-4f22-a1aa-a696345c6fdb)

        
    - **삽입**
        
        리프 노드부터 **상향식**으로 탐색
        
        1️⃣ 트리가 비어있다면 루트 노드를 할당하고 K 삽입
        
        2️⃣ 트리가 비어있지 않다면, 데이털르 삽입할 적절한 리프 노드 탐색
        
        3️⃣ 리프 노드에 데이터를 삽입한다
        
        4️⃣ 리프 노드가 적절한 상태라면 종료 / 부적절한 상태라면 분리
        
        - 적절한 상태 : 해당 노드의 데이터 개수가 허용 범위 안에 있는 것
        
        1. 분리가 일어나지 않고 종료하는 경우 - 적절한 상태
            
            ① 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입
            
            ② 해당 노드가 적절한 상태에 있다면, 삽입을 종료
            
            ![60](https://github.com/2UJ1N/CS/assets/83401978/47beb80a-da17-4b9d-9be3-f52ff2a57b4c)
            
            ![61](https://github.com/2UJ1N/CS/assets/83401978/601b201e-5677-40be-a194-11be24ab6a7c)
            
            1. 분리가 일어나는 경우 - 부적절한 상태
                
                ① 데이터를 삽입할 리프 노드를 탐색하고, 해당 노드에 데이터를 삽입
                
                ②-1 해당 노드의 왼쪽 키는 왼쪽 자식으로, 오른쪽 키는 오른쪽 자식으로 분리
                
                ②-2 부모 노드를 검사해 부모 노드가 부적절한 상태라면 분리 반복
           
               - 삽입 과정 1 - K를 삽입한 노드 탐색 (탐색 과정 반복)
                 ![62](https://github.com/2UJ1N/CS/assets/83401978/e78ce854-3c2a-4469-a69b-e41f07c8f344)
                 
               - 삽입 과정 2 - K를 삽입할 리프노드를 찾아 K 삽입
                 
                    but 부적절한 상태 - 3차 트리는 한 노드에 최대 2개의 데이터를 담을 수 있기 때문
                 ![63](https://github.com/2UJ1N/CS/assets/83401978/38ae0a82-a0bb-48e9-ade6-c16099c86f83)
                 
               - 삽입 과정 3 - 중앙값은 부모 노드에 삽입 + 15는 왼쪽 자식, 17은 오른쪽 자식으로 설정
                 
                    but 부적절한 상태 - 부모 노드
                 ![64](https://github.com/2UJ1N/CS/assets/83401978/2b90a7dc-3732-454c-83d9-d1d77ab5b613)    

               - 삽입 과정 4 - 중앙값은 부모 노드에 삽입 + 14는 왼쪽 자식, 18은 오른쪽 자식으로 설정
                 
                    but 부적절한 상태 - 부모 노드
                ![65](https://github.com/2UJ1N/CS/assets/83401978/0ecb72ac-afc1-44bc-95f1-089bf395a5d2)
                
               - 삽입 과정 5 - 중앙값 16을 부모 노드에 삽입 불가능

                 → 새로운 노드 생성 + 10은 왼쪽 자식, 21은 오른쪽 자식으로 설정

                 ⇒ 모든 노드가 적절한 상태에 있으므로 삽입 종료
                
                ![66](https://github.com/2UJ1N/CS/assets/83401978/fe4c86b4-6019-4830-b7bb-3a02ec83400b)
                

    - **삭제**
        
        삭제 과정에서 M차 트리의 조건이 위반되면 조건에 맞도록 트리를 재구조화 시킨다
        
        ❗ M차 트리의 조건
        - 내부 트리는 M/2 ~ M개의 자식을 가질 수 있다
        - 각 노드는 floor(M/2)-1 ~ M-1의 데이터(key)를 가질 수 있다
        - 노드의 key가 K개라면, 자식 노드의 개수는 K+1개이다.
        
        
        ❗ 설명에 필요한 용어
        
        - Lmax : 현재 노드의 왼쪽 자식들 중 가장 큰 key
        - Rmin : 현재 노드의 오른쪽 자식들 중 가장 작은 key
        - Parent : 현재 노드를 가리키는 부모 노드의 자식 포인터 오른쪽에 있는 key
        (마지막 자식 노드는 부모의 마지막 key)
        - K : 삭제할 key
        - **최소 유지 개수** : M차 트리의 경우 자식은 1~M개, key값은 0~M-1개를 가질 수 있다
        
        1. 리프 노드에서 삭제
            1. 삭제 시 최소 유지 개수 조건을 만족O
                
                : 노드 삭제
               - Case 1-a
                ![67](https://github.com/2UJ1N/CS/assets/83401978/5e6f2478-a211-45e5-a3bf-2b52817d37b0)
                
            1. 최소 유지 개수 조건을 만족X 
            + 형제노드들에게 값을 빌려올 수 O
                
                1️⃣ K ↔ Parent
                
                2️⃣-1 왼쪽 형제 노드에서 값을 빌려올 수 있다면 Lmax ↔ Parent
                
                2️⃣-2 오른쪽 형제 노드에서 값을 빌려올 수 있다면 Rmin ↔ Parent
                
                - Case 1-b ① 19를 제거하면 (14, 17)의 자식 노드 개수 3개여야 하는 조건 위반
                but 왼쪽 형제 노드에게서 값을 빌려올 수 있다
                ![68](https://github.com/2UJ1N/CS/assets/83401978/0c52d1b8-e3a0-4bbc-bba4-5e88460da4e6)
                
                - Case 1-b ② 가장 먼저 K↔Parent 수행
                19는 마지막 자식이었으므로 (14, 17) 중 마지막 key인 17이 Parent
                ![69](https://github.com/2UJ1N/CS/assets/83401978/1d01e0b4-3219-40e7-a43a-93cc4afc280a)
                
                - Case 1-b ③ Lmax↔Parent 수행
                ![70](https://github.com/2UJ1N/CS/assets/83401978/acded5d1-e592-49ed-9c8a-e45d5e7efbd4)
                
                - Case 1-b ④ 제거 완료
                  ![71](https://github.com/2UJ1N/CS/assets/83401978/dee2c9f0-9350-43df-b026-2acd69584372)
                
            3. 최소 유지 개수 조건을 만족X 
            + 형제노드들에게 값을 빌려올 수 X + 부모 노드 분할 O
                
                : 1️⃣ K를 삭제한다
                
                2️⃣ Parent를 부모 노드에서 분할하여 형제 노드에 합친다
                
                → 부모 노드의 key가 하나 줄고, 자식 노드의 수도 하나 줄어들어 조건 만족
                
                - Case 1-c ① 22를 삭제하면 (22, 28)의 자식 수가 2개가 되어 최소 유지 개수 만족 X
                  ![72](https://github.com/2UJ1N/CS/assets/83401978/27c0fb56-4337-44e2-89da-96ec0afab741)
                
                - Case 1-c ② Parent를 분할하여 형제 노드에 합친다
                  ![73](https://github.com/2UJ1N/CS/assets/83401978/ad792b2a-cc14-4132-86cc-62b8a39e390c)

                - Case 1-c ③ 22 제거 완료
                  ![74](https://github.com/2UJ1N/CS/assets/83401978/65f31b50-1041-490c-9505-e91d5b2fd317)
                
            4. 최소 유지 개수 조건을 만족X 
            + 형제노드들에게 값을 빌려올 수 X + 부모 노드 분할 X
                
                case 2-b의 경우와 동일
                
        3. 리프 노드가 아닌 내부 노드에서 삭제
            1. 현재 노드 **or** 자식 노드 key 개수가 최소 유지 개수의 최소보다 큰 경우
                
                : 1️⃣ K↔Lmax or K↔Rmin 
                
                2️⃣ 리프노드의 K 삭제와 과정 동일
                
                - Case 2-a ① 21 삭제 시 자식 노드 개수가 3개로 조건을 만족하지 않는다
                  ![73](https://github.com/2UJ1N/CS/assets/83401978/ad792b2a-cc14-4132-86cc-62b8a39e390c)

                - Case 2-a ② K의 Lmax인 19와 값을 바꾸거나, Rmin인 22와 값을 바꾸면 된다
                이후 리프 노드에서의 삭제 과정을 수행한다
                  ![74](https://github.com/2UJ1N/CS/assets/83401978/65f31b50-1041-490c-9505-e91d5b2fd317)
                
            2. 현재 노드 and 자식 노드 모두 key 개수가 최소 유지 개수보다 작은 경우
                
                : 트리 구조의 재구조화를 수행한다
                
                1️⃣ K를 삭제하고 K의 자식을 하나로 합친다 → N1 노드 생성
                
                2️⃣ K의 부모 노드를 K의 형제 노드에 합친다 → N2 노드 생성
                
                3️⃣ N1이 N2의 자식이 되도록 연결한다
                
                4️⃣-1 if N2의 key 개수가 최대보다 크다면, key 삽입 과정과 동일하게 분할
                
                4️⃣-2 if N2의 key 개수가 최소보다 작다면, 2️⃣번 과정부터 다시 반복
                
                - Case 2-b ① 4를 제거하면 현재 노드 및 자식 노드들의 최소 유지 개수를 만족할 수 없다
                  ![75](https://github.com/2UJ1N/CS/assets/83401978/1ae1057f-0ca8-4091-9796-270a296d5742)
                
                - Case 2-b ② K의 자식 노드들을 모두 합쳐준다 → N1 노드
                  ![76](https://github.com/2UJ1N/CS/assets/83401978/6054655f-79bb-4809-ab8d-a7a6e951d386)
                
                - Case 2-b ③ K의 부모 노드인 10을 K의 형제 노드에 합쳐준다 → N2 노드
                               ④ N1을 N2의 자식으로 연결해 준다
                
                3차 트리지만 key개수가 3개로 너무 많기 때문에 이후 분할을 진행한다
                  ![77](https://github.com/2UJ1N/CS/assets/83401978/c3eb311c-ad9a-4ff9-82e7-c1d0beeec03e)
                

### B*Tree

B-Tree의 단점 - 구조 유지를 위해 추가 연산이 수행되거나 새로운 노드를 생성해야 함 - 을 최소화 하기 위해 B-Tree에서 몇 가지 규칙을 추가한 트리

---
✏️ **B-Tree**와 **B*Tree** 비교

**B-Tree**
기존 노드의 자식 노드 제약 조건 : **M/2**
노드가 가득 차면 분열

**B*Tree**
기존 노드의 자식 노드 제약 조건 : **2M/3**
노드가 가득 차면 이웃한 형제 노드로 재배치 (더 이상 재배치를 할 수 없는 시점에야 분열)

---

- 특징
    - 모든 리프 노드는 같은 레벨에 있다
    - 루트 노드는 리프 노드가 되지 않는 이상 적어도 2개 이상의 자식 노드 O
    - 루트 노드가 아닌 노드들은 2[(M-2)/3]+1 ~ M개의 자식 노드O

### B+Tree

B-Tree의 단점 - 탐색을 위해 노드를 찾아 이동해야 함 - 을 해소하는 B-Tree의 확장 개념

같은 레벨의 모든 키 값이 연결 리스트 형태로 정렬되어 이어져 있다.

![80](https://github.com/2UJ1N/CS/assets/83401978/c78c11a2-55b1-49fa-ab50-c0733aa7c223)

- 구성
    - 리프 노드 - **데이터 노드 - Key, Value**
    - 리프 노드가 아닌 자료 - **인덱스 노드 Value(다음 노드 포인터 주소)**
    
    → 데이터 검색을 위해 리프 노드까지 내려가야 한다
    
    ➡️ 메모리 더 확보 가능 + 탐색 시 리프 노드 데이터만 살피므로 탐색 유리
    
    ⇒ 오늘날 대부분의 데이터 베이스 시스템은 B+Tree 구조 (검색 속도를 위해)
    

---
✏️ **B-Tree**와 **B+Tree** 비교

|  | B-Tree | B+Tree |
| --- | --- | --- |
| 데이터 저장 | 모든 노드가 데이터 저장 가능 | 리프 노드만 데이터 저장 가능 |
| 트리의 높이 | 높음 | 낮음
(한 노드당 key값 많이 가짐) |
| 키 중복 | 없음 | 있음
(리프 노드에 모든 데이터 존재) |
| 전체 확인 시 검색 속도 | 모든 노드 탐색 | 리프 노드에서 선형 탐색 |
| 검색 | 자주 접근가능한 노드를 루트노드 가까이 배치 → 빠름 | 리프 노드까지 가야 데이터 O |

- 탐색 과정

![81](https://github.com/2UJ1N/CS/assets/83401978/68c80033-46b8-47e7-8dc7-8777b034bb29)

---

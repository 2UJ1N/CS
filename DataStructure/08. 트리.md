## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 트리 tree

그래프 중 단방향 그래프 - 트리 구조로 배열된 일종의 계층적 데이터의 집합

![18](https://github.com/2UJ1N/CS/assets/83401978/3526058f-544b-4af7-9fe5-88951b23a2e0)

- 구성
    - **루트 Root** 노드
        
        : 가장 위에 있는 노드
        
        (보통 트리를 탐색할 때 루트 노드를 중심으로 탐색)
        
    - 간선 Edge
    - 노드 Node : 각 데이터
    
    ➡️ 루트라는 하나의 데이터를 시작으로 각 데이터가 여러 개의 간선으로 이루어져 있다
    
    - **부모** 노드 : 상위 노드
    - **자식** 노드 : 하위 노드
    - 형제 노드 : 동일한 부모 노드를 가진 노드
    - 리프 노드 : 자식 노드가 없는 노드

- 특징
    - 부모-자식 계층 구조를 가진다 → 비선형 구조
        
        : D는 H와 I의 부모 노드, H와 I노드는 D의 자식 노드
        
        ➡️ 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 된다
        
    - 트리 구조는 아래로만 뻗어나가므로 방향성이 있고, 사이클이 없다
    
    - 노드가 n개인 트리는 항상 n - 1개의 간선을 가진다. ➡️ V - 1 = E
    - 연결성 continuity : 트리 내의 어떤 노드와 어떤 노드까지 경로는 반드시 '유일무이'하게 존재

- 용어
    - 깊이 depth : 루트 노드로부터 하위 계층의 특정 노드까지의 간선 수, 레벨
    - 레벨 Level : 최상위 노드를 Level0이라고 했을 때 하위 Branch로 연결된 노드의 깊이
    - 차수 Degree : 부모 노드의 자식 노드 개수
    - 서브 트리 : 루트 노드에서 뻗어나오는 큰 트리 구조 내부에, 트리 구조를 갖춘 작은 트리

- 순회 방법
    - **전위 순회 Preorder**
        
        Root ➡️ Left ➡️ Right
        
        ![19](https://github.com/2UJ1N/CS/assets/83401978/e0b0fdd1-06af-4962-9eb4-73b774492a4d)
        
        - 자식 노드를 탐색할 때, 자식 노드가 서브 트리의 루트이면 그 서브트리 내에서 다시, 루트 -> 왼쪽 노드 -> 오른쪽 노드 순서로 탐색을 이어 나간다
    
    - 중위 순회 Inorder
        
        Left ➡️ Root ➡️ Right
        
        ![20](https://github.com/2UJ1N/CS/assets/83401978/8effc0c7-c4c0-466f-9713-90eae97945fe)
        
    - 후위 순회 Postorder
        
        Left ➡️ Right ➡️ Root
        
        ![21](https://github.com/2UJ1N/CS/assets/83401978/d18f7019-0063-4478-8993-801d19f0f003)
        
    - 레벨 순회
        
        레벨에 따라 왼쪽에 있는 노드부터 탐색
        
        ![22](https://github.com/2UJ1N/CS/assets/83401978/6cd1014d-ff24-428e-a0ee-2984d50d8b61)
        
- 사용 예시
    - 컴퓨터 디렉토리 구조

- 종류
    - 편향 트리
        
        : 모든 노드들이 자식을 하나만 가지는 트리
        
    - 이진 트리
        
        : 모든 부모 노드가 2개 이하의 자식을 가진다
        
    - 이진 탐색 트리
        
        : 정렬 조건을 가지고 있는 이진 트리
        
    - 다원 탐색 트리
        
        : 확장된 형태의 이진 탐색 트리 → 높이를 줄이기 위해 사용
        한 노드 내에 최대 m - 1개 요소와 m개의 자식을 가질 수 있는 트리
        
    - AVL 트리
    - 레드 블랙 트리
    - 힙

### 이진 트리 Binary Tree

자식 노드가 최대 2개인 노드들로 구성된 트리

- 종류 - 자료의 삽입/삭제 방법에 따라 구분
    - **정 이진 트리** : 각 노드가 0개 혹은 2개의 자식 노드를 갖는 트리
    - **완전 이진 트리** : 왼쪽에서부터 채워져 있는 이진 트리
    마지막 레벨 제외 모든 레벨이 채워져 있으며 마지막 레벨은 왼쪽부터 채워져 있음
    - **변질 이진 트리** : 자식 노드가 하나만 있는 이진 트리
    - **포화 이진 트리** : 모든 노드가 채워진 이진 트리
    - **균형 이진 트리** : 왼쪽 오른쪽 노드의 높이 차이가 1 이하인 이진 트리
        
        　└ 레드 블랙 트리가 해당
        
    
    ![23](https://github.com/2UJ1N/CS/assets/83401978/b70f83e6-4a04-4b97-8ef8-443166e2acce)
    

### 이진 탐색 트리 BST : Binary Search Tree

이진 탐색 + 연결 리스트를 결합한 이진 트리

- 조건 : **부모 요소보다 작은 노드는 왼쪽에, 큰 노드는 오른쪽에 위치**
    
    모든 노드에 대해서
    
    ✅ 자신의 왼쪽 자식 노드에는 자신보다 작은 값이
    
    ✅ 자신의 오른쪽 자식 노드에는 자신보다 큰 값이 들어있다
    
    ✅ 노드의 데이터 값은 중복되지 않는 유일한 값이며
    
    ✅ 노드의 데이터는 NULL이 아니라, 항상 존재하는 값이다.
    

![24](https://github.com/2UJ1N/CS/assets/83401978/b9f78e24-87d4-4fd7-bd3a-179ae1458620)

- 탐색 과정
    1. 찾고자 하는 데이터 target과 루트 노드 비교 → 찾으면 탐색 종료
    2. target이 루트 노드보다 작을 경우 → 왼쪽 서브트리 탐색 진행
    3. target이 루트 노드보다 클 경우 → 오른쪽 서브트리 탐색 진행
    4. target을 찾지 못할 경우 연산 종료

- 장점
    - 기존 이진 트리보다 탐색이 빠르다
        
        ➡️ 이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료 입력/삭제가 가능하다
        
- 단점
    - 조건 때문에 한 쪽으로 노드들이 몰리는 현상이 발생할 수 있다 (편향 트리)
        
        └ 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문
        
        → 삽입/삭제마다 트리의 구조를 재조정하는 알고리즘을 추가해야 한다
        
        ➡️ 이를 해결하기 위해 균형잡힌 이진검색 트리 고안 → AVL트리, 레드블랙트리
        

- 시간 복잡도
    - (비선형 일반적인) 트리 **O(log n)**
    - 한쪽으로 치우쳐진 트리(최악의 경우) **O(n)**

### AVL 트리

자가 균형 이진 탐색 트리

각 노드의 서브트리 높이 차이가 최대 1을 유지하도록 스스로 균형을 유지하는 트리

- **균형 계수 BF** : Balance Factor : 서브트리의 높이 차이
    
     **`BF(K) = K의 왼쪽 서브 트리 높이 - K의 오른쪽 서브 트리 높이`**
    

➡️ AVL 트리는 모든 노드의 BF가 -1, 0, 1 중 하나여야 한다

➡️ 삽입/삭제 연산 수행 시마다 트리의 균형 계수를 체크하고, 균형 계수가 1보다 커질 때 **회전 연산**을 통해 균형 유지

![25](https://github.com/2UJ1N/CS/assets/83401978/194205a5-eefd-4f2c-a56b-a2f3d7ae2fc8)

- 회전 연산
    - **우회전**
        
        ![26](https://github.com/2UJ1N/CS/assets/83401978/41fb848d-fb9e-439a-8811-2c338f6f6e5e)
        
        1. y노드의 오른쪽 자식 노드를 z노드로 변경
        2. z노드 왼쪽 자식 노드를 y노드의 오른쪽 서브트리 T2로 변경
    
    - **좌회전**
        
        ![27](https://github.com/2UJ1N/CS/assets/83401978/629d9118-bd5b-49e6-8f08-b464842df173)
        
        1. y노드의 왼쪽 자식 노드를 z노드로 변경
        2. z노드의 오른쪽 자식 노드를 y노드의 왼쪽 서브트리 T2로 변경

- 균형이 깨진 경우
    - LL Case (왼쪽-왼쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 왼쪽, 왼쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **우회전**을 적용하면 불균형이 해소된다
        
        ![28](https://github.com/2UJ1N/CS/assets/83401978/fa599320-de05-454d-acd3-9d4bec3e5e80)
        
    - RR Case (오른쪽-오른쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 오른쪽, 오른쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **좌회전**을 적용하면 불균형이 해소된다
        
        ![29](https://github.com/2UJ1N/CS/assets/83401978/7f864bb0-d6a0-49d5-89e6-eee3664a81fe)
        
    - LR Case (왼쪽-오른쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 왼쪽, 오른쪽 노드가 존재할 경우
        
        ➡️ 
        
        1. BF에 이상이 있는 노드(값이 4인노드)의 왼쪽 자식 노드(값이 2인 노드)를 기준으로 **좌회전**을 진행
        2. BF에 이상이 있는 노드(값이 4인 노드)를 기준으로 **우회전**을 진행하면 불균형이 해소
        
        ![30](https://github.com/2UJ1N/CS/assets/83401978/a7c84d9d-cf07-4fe5-9b42-42141b33a067)
        
    - RL Case (오른쪽-왼쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 오른쪽, 왼쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **좌회전**을 적용하면 불균형이 해소된다
        
        1. BF에 이상이 있는 노드(값이 4인노드)의 오른쪽 자식 노드(값이 4인 노드)를 기준으로 **우회전**을 진행
        2. BF에 이상이 있는 노드(값이 4인 노드)를 기준으로 **좌회전**을 진행하면 불균형이 해소
        
        ![31](https://github.com/2UJ1N/CS/assets/83401978/ef2c184e-f84e-4588-9707-cf28406c81f2)
        

- 시간 복잡도
    - 자가 균형(회전, 단일 재구성) **O(1)**
    - 검색 **O(logn)**
        
        : 이진 검색 트리이므로 노드의 수에 비례하는 높이에서 수행
        
    - 삽입 **O(logn)**
        
        : 먼저 이진 검색 트리에서 노드를 삽입하고, AVL 균형을 유지하기 위해 자가 균형 수행
        
    - 삭제 **O(logn)**

### 레드블랙 트리

자가 균형 이진 탐색 트리

각 노드를 **빨강**, **검정** 색으로 매핑한 후, 루트~리프까지의 경로에 나타나는 노드의 색을 제한하여, 트리의 균형을 근사적으로 유지시킬 수 있다

![32](https://github.com/2UJ1N/CS/assets/83401978/6352b648-e589-454c-b5d3-47992ea30b4b)

- 조건
    1. 모든 노드는 **빨간색** 혹은 **검은색**이다
    2. 루트 노드는 검은색이다
    3. 모든 리프 노드(NIL)들은 검은색이다
    (NIL : 자료를 갖지 않고 트리의 끝을 나타내는 노드)
    4. **빨간색** 노드의 자식은 **검은색**이다
    ➡️ **빨간색** 노드가 연속적으로 나올 수 없다
    5. 모든 리프 노드(NIL)에서 Black Depth는 같다
    ➡️ 루트노드에서 리프노드까지 가는 경로에서 만나는 **검은색** 노드의 개수가 같다

- 데이터 삽입
    
    새로운 노드는 항상 **빨간색**으로 삽입한다
    → 4번 조건에 위배되는 상황이 발생할 수 있다 `Double Red`
    
    ![33](https://github.com/2UJ1N/CS/assets/83401978/a21f6dcb-1584-4e06-acf3-fa94281f4856)
    
    (새로 삽입할 노드 **N**(New), 부모 노드 **P**(Parent), 조상 노드 **G**(Grand Parent), 삼촌 노드 **U**(Uncle))
    
    1️⃣ 삼촌 노드가 **검은색**일 때, ⇒ `Restructuring` 수행
    
    2️⃣ 삼촌 노드가 **빨간색**일 때, ⇒ `Recoloring` 수행
    
    - **Restructuring**
        1. 새로 삽입하는 노드 **N**, 부모 노드 **P**, 조상 노드 **G**를 오름차순으로 정렬한다
        2. 셋 중 중간 값을 부모로 만들고, 나머지 둘을 자식으로 만든다
        3. 새로 부모가 된 노드 (중간 값)을 **검은색**, 나머지 자식들을 **빨간색**으로 만든다

        **Restructuring** 1단계
        ![34](https://github.com/2UJ1N/CS/assets/83401978/92c3ad3f-8a4a-41c4-9ff3-5cb8e5841cc1)
        
        **Restructuring** 2단계
        
        ![35](https://github.com/2UJ1N/CS/assets/83401978/e44058b9-6c11-4747-af82-b7fbd571b9a2)
        
        **Restructuring** 3단계
        
        ![36](https://github.com/2UJ1N/CS/assets/83401978/b6005117-8e32-46e4-a00a-6832ee546df9)

        
    - **Recoloring**
        1. 새로 삽입하는 노드 **N**의 부모 노드 **P**와 삼촌 노드 **U**를 **검은색**, 조상 노드 **G**를 **빨간색**으로 바꾼다
            1. 조상 노드 G가 루트 노드라면 검은색으로 바꾼다
            2. 조상 노드 G를 빨간색으로 바꾸었을 때, 또 다시 `Double Red`가 발생한다면 문제가 발생하지 않을 때까지 `Restructuring` 혹은 `Recoloring`을 반복한다
 
        **Recoloring** 1단계
      
        ![37](https://github.com/2UJ1N/CS/assets/83401978/4ed48a12-c482-43d1-9cc3-feb3d3fb5b82)
        
        **Recoloring** 2단계
        
        ![38](https://github.com/2UJ1N/CS/assets/83401978/3e900841-6cf5-440a-9e5f-054cf7788e39)
        
        **Recoloring** 3단계
        
        - `Double Red` 문제 상황 발생한 경우
            
            ![39](https://github.com/2UJ1N/CS/assets/83401978/43ce1a1e-44e4-408d-8484-b52195cb08af)
            
            ![40](https://github.com/2UJ1N/CS/assets/83401978/728591a6-1a7c-4ac9-aed6-fdabe229feb3)
            
    
    - 시간 복잡도
        - **O(log n)**
        이진 검색 트리이므로 노드의 수에 비례하는 높이에서 수행
        but `Recoloring` 시 최악의 경우 O(log n)이 걸리게 된다

---
✏️ **AVL Tree**와 **Red Black Tree** 비교

**AVL Tree** 
- R-B 트리보다 더 빠른 검색 가능 
  : AVL 트리가 더 엄격한 균형을 유지하고 있기 때문
➡️ 조회 속도가 중요한 DB에서 사용

**Red Black Tree**
- AVL 트리보다 빠른 삽입, 삭제 가능
  : AVL 트리보다 느슨한 균형을 유지하고 있기 때문
- AVL 트리보다 더 많은 공간 복잡도 필요
 ➡️ 대부분의 map, multimap, multiset에서 사용

</aside>

## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 트리 tree

그래프 중 단방향 그래프 - 트리 구조로 배열된 일종의 계층적 데이터의 집합

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/ad70f25a-ccd8-44a9-a5bb-8675e5a36dad/Untitled.png)

- 구성
    - **루트 Root** 노드
        
        : 가장 위에 있는 노드
        
        (보통 트리를 탐색할 때 루트 노드를 중심으로 탐색)
        
    - 간선 Edge
    - 노드 Node : 각 데이터
    
    ➡️ 루트라는 하나의 데이터를 시작으로 각 데이터가 여러 개의 간선으로 이루어져 있다
    
    - **부모** 노드 : 상위 노드
    - **자식** 노드 : 하위 노드
    - 형제 노드 : 동일한 부모 노드를 가진 노드
    - 리프 노드 : 자식 노드가 없는 노드

- 특징
    - 부모-자식 계층 구조를 가진다 → 비선형 구조
        
        : D는 H와 I의 부모 노드, H와 I노드는 D의 자식 노드
        
        ➡️ 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 된다
        
    - 트리 구조는 아래로만 뻗어나가므로 방향성이 있고, 사이클이 없다
    
    - 노드가 n개인 트리는 항상 n - 1개의 간선을 가진다. ➡️ V - 1 = E
    - 연결성 continuity : 트리 내의 어떤 노드와 어떤 노드까지 경로는 반드시 '유일무이'하게 존재

- 용어
    - 깊이 depth : 루트 노드로부터 하위 계층의 특정 노드까지의 간선 수, 레벨
    - 레벨 Level : 최상위 노드를 Level0이라고 했을 때 하위 Branch로 연결된 노드의 깊이
    - 차수 Degree : 부모 노드의 자식 노드 개수
    - 서브 트리 : 루트 노드에서 뻗어나오는 큰 트리 구조 내부에, 트리 구조를 갖춘 작은 트리

- 순회 방법
    - **전위 순회 Preorder**
        
        Root ➡️ Left ➡️ Right
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/846f9145-8c1e-4845-944b-f9d458d64d0f/Untitled.png)
        
        - 자식 노드를 탐색할 때, 자식 노드가 서브 트리의 루트이면 그 서브트리 내에서 다시, 루트 -> 왼쪽 노드 -> 오른쪽 노드 순서로 탐색을 이어 나간다
    
    - 중위 순회 Inorder
        
        Left ➡️ Root ➡️ Right
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/9f1bd932-40f2-4685-adc0-746c22a0b9f5/Untitled.png)
        
    - 후위 순회 Postorder
        
        Left ➡️ Right ➡️ Root
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/bc6be01a-1c85-4382-be61-5c818ebaaa84/Untitled.png)
        
    - 레벨 순회
        
        레벨에 따라 왼쪽에 있는 노드부터 탐색
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/0de1f21d-f562-4bdf-a399-46ecaefe6839/Untitled.png)
        
- 사용 예시
    - 컴퓨터 디렉토리 구조

- 종류
    - 편향 트리
        
        : 모든 노드들이 자식을 하나만 가지는 트리
        
    - 이진 트리
        
        : 모든 부모 노드가 2개 이하의 자식을 가진다
        
    - 이진 탐색 트리
        
        : 정렬 조건을 가지고 있는 이진 트리
        
    - 다원 탐색 트리
        
        : 확장된 형태의 이진 탐색 트리 → 높이를 줄이기 위해 사용
        한 노드 내에 최대 m - 1개 요소와 m개의 자식을 가질 수 있는 트리
        
    - AVL 트리
    - 레드 블랙 트리
    - 힙

### 이진 트리 Binary Tree

자식 노드가 최대 2개인 노드들로 구성된 트리

- 종류 - 자료의 삽입/삭제 방법에 따라 구분
    - **정 이진 트리** : 각 노드가 0개 혹은 2개의 자식 노드를 갖는 트리
    - **완전 이진 트리** : 왼쪽에서부터 채워져 있는 이진 트리
    마지막 레벨 제외 모든 레벨이 채워져 있으며 마지막 레벨은 왼쪽부터 채워져 있음
    - **변질 이진 트리** : 자식 노드가 하나만 있는 이진 트리
    - **포화 이진 트리** : 모든 노드가 채워진 이진 트리
    - **균형 이진 트리** : 왼쪽 오른쪽 노드의 높이 차이가 1 이하인 이진 트리
        
        　└ 레드 블랙 트리가 해당
        
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/54e2e1ac-77dc-4107-b157-d0f83a5f1d8e/Untitled.png)
    

### 이진 탐색 트리 BST : Binary Search Tree

이진 탐색 + 연결 리스트를 결합한 이진 트리

- 조건 : **부모 요소보다 작은 노드는 왼쪽에, 큰 노드는 오른쪽에 위치**
    
    모든 노드에 대해서
    
    ✅ 자신의 왼쪽 자식 노드에는 자신보다 작은 값이
    
    ✅ 자신의 오른쪽 자식 노드에는 자신보다 큰 값이 들어있다
    
    ✅ 노드의 데이터 값은 중복되지 않는 유일한 값이며
    
    ✅ 노드의 데이터는 NULL이 아니라, 항상 존재하는 값이다.
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/e3f2b4fe-1537-4a89-bf6e-4e9de4540c88/Untitled.png)

- 탐색 과정
    1. 찾고자 하는 데이터 target과 루트 노드 비교 → 찾으면 탐색 종료
    2. target이 루트 노드보다 작을 경우 → 왼쪽 서브트리 탐색 진행
    3. target이 루트 노드보다 클 경우 → 오른쪽 서브트리 탐색 진행
    4. target을 찾지 못할 경우 연산 종료

- 장점
    - 기존 이진 트리보다 탐색이 빠르다
        
        ➡️ 이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료 입력/삭제가 가능하다
        
- 단점
    - 조건 때문에 한 쪽으로 노드들이 몰리는 현상이 발생할 수 있다 (편향 트리)
        
        └ 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문
        
        → 삽입/삭제마다 트리의 구조를 재조정하는 알고리즘을 추가해야 한다
        
        ➡️ 이를 해결하기 위해 균형잡힌 이진검색 트리 고안 → AVL트리, 레드블랙트리
        

- 시간 복잡도
    - (비선형 일반적인) 트리 **O(log n)**
    - 한쪽으로 치우쳐진 트리(최악의 경우) **O(n)**

### AVL 트리

자가 균형 이진 탐색 트리

각 노드의 서브트리 높이 차이가 최대 1을 유지하도록 스스로 균형을 유지하는 트리

- **균형 계수 BF** : Balance Factor : 서브트리의 높이 차이
    
     **`BF(K) = K의 왼쪽 서브 트리 높이 - K의 오른쪽 서브 트리 높이`**
    

➡️ AVL 트리는 모든 노드의 BF가 -1, 0, 1 중 하나여야 한다

➡️ 삽입/삭제 연산 수행 시마다 트리의 균형 계수를 체크하고, 균형 계수가 1보다 커질 때 **회전 연산**을 통해 균형 유지

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/cab0cce2-4284-4d2c-9faf-dcffbad6afaa/Untitled.png)

- 회전 연산
    - **우회전**
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/deffd73c-c90b-4028-802c-f79a5d79ab5d/Untitled.png)
        
        1. y노드의 오른쪽 자식 노드를 z노드로 변경
        2. z노드 왼쪽 자식 노드를 y노드의 오른쪽 서브트리 T2로 변경
    
    - **좌회전**
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/580d7b19-0556-42f2-8937-ca77efc96ad8/Untitled.png)
        
        1. y노드의 왼쪽 자식 노드를 z노드로 변경
        2. z노드의 오른쪽 자식 노드를 y노드의 왼쪽 서브트리 T2로 변경

- 균형이 깨진 경우
    - LL Case (왼쪽-왼쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 왼쪽, 왼쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **우회전**을 적용하면 불균형이 해소된다
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/5ea71e43-d1fb-4d88-b9cc-e9d07b786020/Untitled.png)
        
    - RR Case (오른쪽-오른쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 오른쪽, 오른쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **좌회전**을 적용하면 불균형이 해소된다
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/3dfa6abe-c9de-42ca-b816-29cc7b6975ef/Untitled.png)
        
    - LR Case (왼쪽-오른쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 왼쪽, 오른쪽 노드가 존재할 경우
        
        ➡️ 
        
        1. BF에 이상이 있는 노드(값이 4인노드)의 왼쪽 자식 노드(값이 2인 노드)를 기준으로 **좌회전**을 진행
        2. BF에 이상이 있는 노드(값이 4인 노드)를 기준으로 **우회전**을 진행하면 불균형이 해소
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/14bd0bb1-db37-4df8-b149-5a8d6df0a3ee/Untitled.png)
        
    - RL Case (오른쪽-왼쪽)
        
        : BF가 -1~1을 벗어난 노드를 기준으로 오른쪽, 왼쪽 노드가 존재할 경우
        
        ➡️ 해당 노드를 기준으로 **좌회전**을 적용하면 불균형이 해소된다
        
        1. BF에 이상이 있는 노드(값이 4인노드)의 오른쪽 자식 노드(값이 4인 노드)를 기준으로 **우회전**을 진행
        2. BF에 이상이 있는 노드(값이 4인 노드)를 기준으로 **좌회전**을 진행하면 불균형이 해소
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/3ee42981-0c79-462f-9112-095928eccd22/Untitled.png)
        

- 시간 복잡도
    - 자가 균형(회전, 단일 재구성) **O(1)**
    - 검색 **O(logn)**
        
        : 이진 검색 트리이므로 노드의 수에 비례하는 높이에서 수행
        
    - 삽입 **O(logn)**
        
        : 먼저 이진 검색 트리에서 노드를 삽입하고, AVL 균형을 유지하기 위해 자가 균형 수행
        
    - 삭제 **O(logn)**

### 레드블랙 트리

자가 균형 이진 탐색 트리

각 노드를 **빨강**, **검정** 색으로 매핑한 후, 루트~리프까지의 경로에 나타나는 노드의 색을 제한하여, 트리의 균형을 근사적으로 유지시킬 수 있다

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/aca6bbe8-878d-492e-94a7-849667847f68/Untitled.png)

- 조건
    1. 모든 노드는 **빨간색** 혹은 **검은색**이다
    2. 루트 노드는 검은색이다
    3. 모든 리프 노드(NIL)들은 검은색이다
    (NIL : 자료를 갖지 않고 트리의 끝을 나타내는 노드)
    4. **빨간색** 노드의 자식은 **검은색**이다
    ➡️ **빨간색** 노드가 연속적으로 나올 수 없다
    5. 모든 리프 노드(NIL)에서 Black Depth는 같다
    ➡️ 루트노드에서 리프노드까지 가는 경로에서 만나는 **검은색** 노드의 개수가 같다

- 데이터 삽입
    
    새로운 노드는 항상 **빨간색**으로 삽입한다
    → 4번 조건에 위배되는 상황이 발생할 수 있다 `Double Red`
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/b5a45958-13ae-4f97-bd51-851ee46ad105/Untitled.png)
    
    (새로 삽입할 노드 **N**(New), 부모 노드 **P**(Parent), 조상 노드 **G**(Grand Parent), 삼촌 노드 **U**(Uncle))
    
    1️⃣ 삼촌 노드가 **검은색**일 때, ⇒ `Restructuring` 수행
    
    2️⃣ 삼촌 노드가 **빨간색**일 때, ⇒ `Recoloring` 수행
    
    - **Restructuring**
        1. 새로 삽입하는 노드 **N**, 부모 노드 **P**, 조상 노드 **G**를 오름차순으로 정렬한다
        2. 셋 중 중간 값을 부모로 만들고, 나머지 둘을 자식으로 만든다
        3. 새로 부모가 된 노드 (중간 값)을 **검은색**, 나머지 자식들을 **빨간색**으로 만든다
        
        ![**Restructuring** 1단계](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/de5dc437-44c4-4056-aeac-b4732ff8ce87/Untitled.png)
        
        **Restructuring** 1단계
        
        ![**Restructuring** 2단계](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/3e72f9b5-1d00-46ab-b541-5757c2d33b63/Untitled.png)
        
        **Restructuring** 2단계
        
        ![**Restructuring** 3단계](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/f561ac32-b1df-4434-a8af-005fce7156a9/Untitled.png)
        
        **Restructuring** 3단계
        
    - **Recoloring**
        1. 새로 삽입하는 노드 **N**의 부모 노드 **P**와 삼촌 노드 **U**를 **검은색**, 조상 노드 **G**를 **빨간색**으로 바꾼다
            1. 조상 노드 G가 루트 노드라면 검은색으로 바꾼다
            2. 조상 노드 G를 빨간색으로 바꾸었을 때, 또 다시 `Double Red`가 발생한다면 문제가 발생하지 않을 때까지 `Restructuring` 혹은 `Recoloring`을 반복한다
        
        ![**Recoloring** 1단계](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/f92611ed-1691-4b9c-9736-cd385302f9aa/Untitled.png)
        
        **Recoloring** 1단계
        
        ![**Recoloring** 2단계](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/d43c3cab-5df4-412c-ab93-7a7cb8ede29b/Untitled.png)
        
        **Recoloring** 2단계
        
        - `Double Red` 문제 상황 발생한 경우
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/617f1125-244a-4295-8b7c-6082a03c3828/Untitled.png)
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/6ec04094-6764-4c44-8d48-71bec395ad36/Untitled.png)
            
    
    - 시간 복잡도
        - **O(log n)**
        이진 검색 트리이므로 노드의 수에 비례하는 높이에서 수행
        but `Recoloring` 시 최악의 경우 O(log n)이 걸리게 된다

<aside>
✏️ **AVL Tree**와 **Red Black Tree** 비교

**AVL Tree** 
- R-B 트리보다 더 빠른 검색 가능 
  : AVL 트리가 더 엄격한 균형을 유지하고 있기 때문
➡️ 조회 속도가 중요한 DB에서 사용

**Red Black Tree**
- AVL 트리보다 빠른 삽입, 삭제 가능
  : AVL 트리보다 느슨한 균형을 유지하고 있기 때문
- AVL 트리보다 더 많은 공간 복잡도 필요
 ➡️ 대부분의 map, multimap, multiset에서 사용

</aside>
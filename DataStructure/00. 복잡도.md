# 자료구조 data structure

: 효울적으로 데이터를 관리, 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

## 복잡도

알고리즘을 평가하는 2가지 요소 - 속도, 메모리 사용량

### 시간 복잡도

문제를 해결하는 데 걸리는 시간과 입력의 함수 관계

➡️ 어떠한 알고리즘 로직이 ‘얼마나 오랜 시간’이 걸리는지

➡️➡️ 효율적인 코드로 개선하는데 사용되는 척도

- 빅-오 표기법
    
    : 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타내는 것
    
    T(n)이 다항식으로 표현된 경우, 최고차 항의 차수가 빅-오가 된다.
    
    → 가장 많이 영향을 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것
    
    ➡️ 데이터 수의 증가에 따른 연산 횟수의 증가 형태를 표현한 것
    

![O(n^2) 보다 O(n), O(logn), O(1)을 지향해야 한다 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/b490120e-687f-4ff3-b59f-0fcde554d4fb/Untitled.png)

O(n^2) 보다 O(n), O(logn), O(1)을 지향해야 한다 

- 대표적인 빅-오
    - O(1)
        
        : 상수형 빅-오
        
        데이터 수에 상관없이 연산 횟수가 고정인 유형의 알고리즘
        
    - O(logN)
        
        : 로그형 빅-오
        
        데이터 수의 증가율에 비해 연산 횟수의 증가율이 훨씬 낮은 알고리즘
        
    - O(N)
        
        : 선형 빅-오
        
        데이터 수와 연산 횟수가 비례하는 알고리즘
        
    - O(NlogN)
        
        : 선형로그형 빅-오
        
        데이터 수가 2배 증가할 때 연산 횟수는 2배를 조금 넘게 증가하는 알고리즘
        
    - O(N^2)
        
        데이터 수의 제곱에 해당하는 연산 횟수를 요구하는 알고리즘
        
        → 데이터 양이 많은 경우에는 사용하기 부적절
        
    - O(N^3)
        
        데이터 수의 세 제곱에 해당하는 연산 횟수를 요구하는 알고리즘
        
        → 데이터 양이 많은 경우에는 사용하기 부적절
        
    - O(2^N)
        
        : 지수형 빅-오
        
        → 사용하기에 매우 무리가 있는 알고리즘
        

- 성능(수행시간, 연산횟수)의 대소
    
    O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N)
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/66d16c62-9d8d-4715-b91c-1cdaaa4ac319/Untitled.png)

### 공간 복잡도

프로그램을 실행시켰을 때, 필요로 하는 자원 공간의 양

정적 변수로 선언된 것 + 동적으로 재귀함수 등을 통해 공간을 계속해서 필요로 할 경우

추상 자료형 ADT : Abstract Data Type

: 구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지 나열한 것
## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 힙 Heap

데이터에서 최댓값과 최솟값을 빠르게 찾기 위해 사용하는 완전 이진 트리

- 종류
    
    ![43](https://github.com/2UJ1N/CS/assets/83401978/399c64af-a85b-4d76-b58d-a5b276c53a1a)
    
    - **최대 힙(max heap)**
        
        부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 같은 완전 이진 트리
        
        key(부모 노드) >= key(자식 노드)
        
    - **최소 힙(min heap)**
        
        부모 노드의 키 값이 자식 노드의 키 값보다 항상 작거나 같은 완전 이진 트리
        
        key(부모 노드) <= key(자식 노드)
        
        ![44](https://github.com/2UJ1N/CS/assets/83401978/4009d613-a02c-4d0c-bc37-0bb845f1fc70)
        

- 특징
    - 부모 노드의 인덱스가 1, 자식은 왼쪽 인덱스부터 2, 3 순서이다
        - (왼쪽 자식 노드의 인덱스) = (부모 노드의 인덱스) * 2
        - (오른쪽 자식 노드의 인덱스) = (부모 노드의 인덱스) * 2 + 1
    - (부모 노드의 인덱스) = (자식 노드 인덱스) // 2
    - 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다
        
        (큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도)
        
    - 중복 값을 허용한다

- 필요성
    
    최댓값, 최솟값을 찾을 때 보다 빠르게 이용할 수 있다.
    
    - `배열` 검색 시 Ο(n)
    - `힙` 검색 시 O(logn)

- 사용 예시
    - 우선순위 큐 구현
    - 힙 정렬 구현
    - 최댓값/최솟값을 빠르게 찾을 때
    - 최단 경로를 찾을 때
    - 최소 신장 트리를 찾아야 할 때

- 동작 과정
    - **데이터 삽입**
        
        1️⃣ 새로운 노드를 **힙의 마지막 노드(왼쪽 최하단부 노드)에 삽입 
        └** 우선순위가 가장 낮다고 가정
        
        2️⃣ 새로운 노드를 부모 노드들과 교환
        
        3️⃣ 올바르게 위치할 때까지 2️⃣ 반복
        
        - **`최대 힙 Max heap`**
            
            ![45](https://github.com/2UJ1N/CS/assets/83401978/a5b86b0b-d2d3-4ecb-aa8d-8c70fcb8879e)
            
        - **`최소 힙 Min heap`**
            
            ![46](https://github.com/2UJ1N/CS/assets/83401978/4a1c7032-106d-478b-b2c7-091aa8694830)
            
    - **데이터 삭제**
        
        힙 자료구조의 목표는 최댓값/최솟값을 알아내는 것
        ➡️ **데이터가 삭제 시 루트 노드가 삭제**
        
        1️⃣ 루트 노드를 삭제
        
        2️⃣ 삭제된 루트 노드에는 **힙의 마지막 노드 N를 가져옴**
        
        3️⃣ N의 왼쪽, 오른쪽 자식 노드 중 더 우선순위가 높은 것과 비교 진행
        
        4️⃣ 최대 힙/최소 힙의 구조를 유지할 때까지 3️⃣ 반복
        
        - **`최대 힙 Max heap`**
            
            ![47](https://github.com/2UJ1N/CS/assets/83401978/ef51566e-1926-4653-bc39-51932cc66667)
            
        - **`최소 힙 Min heap`**
            
            ![48](https://github.com/2UJ1N/CS/assets/83401978/d2dedd6f-c381-46fa-abb3-ca665990692d)
            
- 구현
    
    `import heapq`
    
    - heapq모듈은 최소 힙 구조 → 가장 작은 요소가 heap[0]에 위치
        
        ➡️ 힙을 만들기 위해서는 초기화된 리스트[]를 사용하거나 heapify를 통해 값이 들어있는 리스트를 힙으로 변환
        
    
    ```python
    import heapq
    
    heap = []
    ```
    
    - 데이터 **삽입**
        
        모듈의 `heappush()` 함수 사용
        
        첫 번째 인자로는 *대상 리스트*를, 두 번째 인자로는 *삽입할 값*을 전달한다.
        
        ```python
        heapq.heappush(heap, 10)
        heapq.heappush(heap, 6)
        heapq.heappush(heap, 13)
        heapq.heappush(heap, 5)
        
        print(heap)
        # [5, 6, 13, 10]
        ```
        
    
    - 데이터 **삭제**
        
        모듈의 `heappop()` 함수 사용
        
        대상 리스트를 인자로 넘기면, 최솟값을 삭제한 뒤에 반환한다.
        
        ```python
        print(heapq.heappop(heap))
        print(heap)
        # 5
        # [6, 13, 10]
        ```
        
        삭제하지 않고 최솟값을 출력하고 싶다면
        
        ```python
        print(heap[0])
        # 6
        ```
        
        - `heap[1]`에는 두 번째로 작은 원소가 들어있지 않다.
        └최소 힙은 **최솟값**을 빠르게 찾는 알고리즘이지, 작은 순서대로 정렬하는 알고리즘이 X
    
    - 기존의 리스트를 힙으로 변환
        
        모듈의 `heapify()` 함수 사용
        
        ```python
        heap = [7, 2, 4, 3, 1]
        heapq.heapify(heap)
        
        print(heap)
        # [1, 2, 4, 3, 7]
        ```

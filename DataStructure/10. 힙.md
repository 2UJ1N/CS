## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 힙 Heap

데이터에서 최댓값과 최솟값을 빠르게 찾기 위해 사용하는 완전 이진 트리

- 종류
    
    !https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2F8ddbc281-c845-45c0-81d6-8ce0d49b25d9%2Fimage.png
    
    - **최대 힙(max heap)**
        
        부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 같은 완전 이진 트리
        
        key(부모 노드) >= key(자식 노드)
        
    - **최소 힙(min heap)**
        
        부모 노드의 키 값이 자식 노드의 키 값보다 항상 작거나 같은 완전 이진 트리
        
        key(부모 노드) <= key(자식 노드)
        
        !https://velog.velcdn.com/images/gnwjd309/post/6be4941d-5dfc-49ea-8ca3-833fcb690422/image.png
        

- 특징
    - 부모 노드의 인덱스가 1, 자식은 왼쪽 인덱스부터 2, 3 순서이다
        - (왼쪽 자식 노드의 인덱스) = (부모 노드의 인덱스) * 2
        - (오른쪽 자식 노드의 인덱스) = (부모 노드의 인덱스) * 2 + 1
    - (부모 노드의 인덱스) = (자식 노드 인덱스) // 2
    - 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다
        
        (큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도)
        
    - 중복 값을 허용한다

- 필요성
    
    최댓값, 최솟값을 찾을 때 보다 빠르게 이용할 수 있다.
    
    - `배열` 검색 시 Ο(n)
    - `힙` 검색 시 O(logn)

- 사용 예시
    - 우선순위 큐 구현
    - 힙 정렬 구현
    - 최댓값/최솟값을 빠르게 찾을 때
    - 최단 경로를 찾을 때
    - 최소 신장 트리를 찾아야 할 때

- 동작 과정
    - **데이터 삽입**
        
        1️⃣ 새로운 노드를 **힙의 마지막 노드(왼쪽 최하단부 노드)에 삽입 
        └** 우선순위가 가장 낮다고 가정
        
        2️⃣ 새로운 노드를 부모 노드들과 교환
        
        3️⃣ 올바르게 위치할 때까지 2️⃣ 반복
        
        - `**최대 힙 Max heap**`
            
            !https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2F73220cd3-a136-4ada-8234-91c26f9199ee%2Fimage.png
            
        - `**최소 힙 Min heap**`
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/abe5d768-7e80-46f9-ba5b-e1870d2bbab6/Untitled.png)
            
    - **데이터 삭제**
        
        힙 자료구조의 목표는 최댓값/최솟값을 알아내는 것
        ➡️ **데이터가 삭제 시 루트 노드가 삭제**
        
        1️⃣ 루트 노드를 삭제
        
        2️⃣ 삭제된 루트 노드에는 **힙의 마지막 노드 N를 가져옴**
        
        3️⃣ N의 왼쪽, 오른쪽 자식 노드 중 더 우선순위가 높은 것과 비교 진행
        
        4️⃣ 최대 힙/최소 힙의 구조를 유지할 때까지 3️⃣ 반복
        
        - `**최대 힙 Max heap**`
            
            !https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2Ff33d8046-50c6-4684-8c6c-0ccd687b4211%2Fimage.png
            
        - `**최소 힙 Min heap**`
        - 
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/5cef293e-82b8-4e6f-b86c-b0ae9e67f7ff/Untitled.png)
            
- 구현
    
    `import heapq`
    
    - heapq모듈은 최소 힙 구조 → 가장 작은 요소가 heap[0]에 위치
        
        ➡️ 힙을 만들기 위해서는 초기화된 리스트[]를 사용하거나 heapify를 통해 값이 들어있는 리스트를 힙으로 변환
        
    
    ```python
    import heapq
    
    heap = []
    ```
    
    - 데이터 **삽입**
        
        모듈의 `heappush()` 함수 사용
        
        첫 번째 인자로는 *대상 리스트*를, 두 번째 인자로는 *삽입할 값*을 전달한다.
        
        ```python
        heapq.heappush(heap, 10)
        heapq.heappush(heap, 6)
        heapq.heappush(heap, 13)
        heapq.heappush(heap, 5)
        
        print(heap)
        # [5, 6, 13, 10]
        ```
        
    
    - 데이터 **삭제**
        
        모듈의 `heappop()` 함수 사용
        
        대상 리스트를 인자로 넘기면, 최솟값을 삭제한 뒤에 반환한다.
        
        ```python
        print(heapq.heappop(heap))
        print(heap)
        # 5
        # [6, 13, 10]
        ```
        
        삭제하지 않고 최솟값을 출력하고 싶다면
        
        ```python
        print(heap[0])
        # 6
        ```
        
        - `heap[1]`에는 두 번째로 작은 원소가 들어있지 않다.
        └최소 힙은 **최솟값**을 빠르게 찾는 알고리즘이지, 작은 순서대로 정렬하는 알고리즘이 X
    
    - 기존의 리스트를 힙으로 변환
        
        모듈의 `heapify()` 함수 사용
        
        ```python
        heap = [7, 2, 4, 3, 1]
        heapq.heapify(heap)
        
        print(heap)
        # [1, 2, 4, 3, 7]
        ```
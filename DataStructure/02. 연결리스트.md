## 선형 자료구조

요소가 일렬로 나열되어 있는 자료구조

## 연결 리스트 Linked-List

여러 개의 노드들이 순차적으로 연결된 형태를 갖는 자료구조

![4](https://github.com/2UJ1N/CS/assets/83401978/339d8791-66dc-4f89-b700-d88c1801b900)

- 구성 요소
    
    노드 (데이터 + 다음 노드가 저장된 주소 값(포인터))
    
    - Head : 첫 번째 노드를 가리키는 포인터
    - Tail : 마지막 노드를 가리키는 포인터
        - 마지막 노드의 다음 주소 값은 `NULL`
    
    ➡️ 노드가 메모리에 연속적으로 저장되지 않아도 필요한 연산 수행 가능
    
    ➡️ 데이터 추가, 삭제가 자유롭다(기존 노드들의 위치를 변경할 필요가 없다)
    

- 특징
    - 메모리를 연속적으로 사용하지 않는다
        
        ➡️ 순차적으로 접근하는 경우에는 불리하지만 노드가 연결되어 있어 삽입/삭제에 용이하다
        

- 시간복잡도
    - 삽입/삭제
        - 처음 부분 : O(1)
        - 중간 부분 : O(n) - 탐색 시간이 소요된다
        - 마지막 부분
            - 끝을 가리키는 별도의 포인터를 갖는 경우 O(1)
            - 끝을 가리키는 별도의 포인터가 없는 경우 O(n) - 탐색 시간 소요
    - 검색 O(n) : 요소 검색을 위해서 해당 노드까지 차례로 하나씩 탐색해야 함

- 종류
    
    ### 이중 연결 리스트 Doubly Linked List
    
    단순 연결 리스트와 다르게 전/후로 탐색이 가능한 구조이다.
    
    ![5](https://github.com/2UJ1N/CS/assets/83401978/ea986bcb-d0c9-48b6-8f94-7e66c951621c)
    
    - 구성 요소
        - 이전 노드의 주소
        - 데이터
        - 다음 노드의 주소
        
        ➡️ 양방향 탐색 가능
        
    
    - 장점
        - 단순 연결 리스트에서는 탐색 시 최악의 경우 n번의 탐색을 해야 하지만, 
        이중 연결 리스트는 얻고자 하는 데이터의 위치가 tail에 가깝다면 tail부터 역방향 탐색이 가능하기 때문에 탐색 시간을 줄일 수 있다
            
            ![6](https://github.com/2UJ1N/CS/assets/83401978/7332d4e2-14af-4e5d-8d18-b003ca4614fe)
            
    - 단점
        - 구현이 어렵다
        - 주소 값 2개를 저장해야 하기 때문에 필요한 메모리 양이 증가
    
    ### 원형 연결 리스트 Circular Linked List
    
    단순 연결 리스트의 마지막 노드가 null을 가리키는 것이 아닌, 처음 노드를 가리키는 구조이다.
    
    ➡️ **순환 구조** → 어떤 노드에서든 다른 노드에 모두 접근 가능 ⇒ 삽입/삭제 연산의 효율 
    
    ![7](https://github.com/2UJ1N/CS/assets/83401978/f7e8c223-b716-4dd9-afab-7c47b8046639)
    
    - 이중 연결 리스트도 마지막 노드가 처음 노드를 가리키는 구조가 되면 이중 원형 연결 리스트라고 한다.
        
        ![8](https://github.com/2UJ1N/CS/assets/83401978/19d196ee-fd82-4508-9408-d7b3da603bdd)
        

---
### ✏️ 배열과 연결 리스트 비교

**장점**
- **배열** : index를 통한 빠른 접근 가능
- **연결 리스트** : 삽입/삭제가 용이하다
                         원소를 메모리 어디에든 저장이 가능하다

**단점**
- **배열** : 삽입/삭제에 시간이 오래 걸린다
            크기가 고정적이다
            배열 중간에 있는 데이터가 삭제되면 공간 낭비가 발생한다
- **연결 리스트** : index를 통한 임의 접근이 불가능해서 처음부터 탐색을 진행해야 한다.
                        삽입/삭제 연산시 `메모리 할당, 해제`가 일어나는데 이때 시스템 콜을 사용하기 때문에 시간 소요가 발생한다

**용도**
- **배열** : 빠른 접근이 요구되고, 데이터의 삽입/삭제가 적을 때
- **연결 리스트** : 삽입/삭제 연산이 잦고, 검색 빈도가 적을 때

</aside>

## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 그래프 graph

단순히 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조 

→ 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조

!https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F0777f192-9756-48c9-9ed2-2e67a04c09a1%2Fimage.png

- 구성요소
    - **정점 Vertex**
        
        = 노드(node), 데이터가 저장되는 그래프 기본 원소
        
    - **간선 Edge**
        
        = 링크(link), 정점간의 관계를 나타냄
        
    - **차수 Degree** : 정점 하나에 연결된 간선의 수
        - 진출 차수 out-degree : 정점 하나를 기준으로 나가는 간선
        - 진입 차수 in-degree : 정점을 기준으로 들어오는 간선
    - 인접 정점 adjacent vertex : 간선에 의해 연결된 정점
    - 단순 경로 simple path : 동일한 간선을 지나지 않는 경로
    - 가중치 : 간선과 정점 사이에 드는 비용

- 종류
    - 무방향 그래프
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F51f4cb8a-46da-4297-a9e5-26beae1d10c8%2Fimage.png
        
    - 방향 그래프
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F832e8427-5f72-412c-98f0-779e257ca2cc%2Fimage.png
        
    - 가중치 그래프
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F430d0bbb-77e5-4c4c-90f6-d44ee507816b%2Fimage.png
        
    - 완전 그래프
        
        : 정점에 대해 가능한 모든 간선을 가진 그래프
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2Fafcc3bb5-7955-41dd-b04e-7c38164edfc7%2Fimage.png
        
    - 연결 그래프
        
        : 임의의 두 정점 사이에 경로가 항상 존재하는 그래프
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/35462a12-786e-4778-9825-49b29e2aa700/Untitled.png)
        
    - 루프 : 한 정점에서 시작해 같은 정점으로 들어오는 간선
        
        ![루프 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/35286cbf-26da-41b3-93ef-ce8efaebc648/Untitled.png)
        
        루프 
        
        - 단순 그래프 : 두 정점 사이에 간선이 1개 이하이고 루프가 존재하지 않는 그래프
    - 사이클 : 임의의 한 점에서 출발해 자기 자신으로 돌아올 수 있는 경로
        - 순환 그래프 : 그래프 안에 사이클이 하나라도 있는 그래프
            
            ![순환 그래프 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/5606dc0d-6624-446f-a4bb-e43c40f97e9f/Untitled.png)
            
            순환 그래프 
            
        - 비순환 그래프 : 그래프 안에 사이클이 하나도 없는 그래프

- 그래프 구현 방법
    1. 인접 행렬
    2. 인접 리스트
    
    - **인접 행렬 Adjacency Matrix**
        
        : 그래프의 연결 관계를 2차원 배열로 나타내는 방식
        인접 행렬 adj[i][j] 는 노드 i에서 노드 j로 가는 간선이 있으면 1, 아니면 0
        (간선에 가중치가 있는 그래프라면 1 대신 가중치의 값으로 표현)
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F035d0fb8-6a69-44d8-8ae0-cfd4410d8f7f%2Fimage.png
        
        - 구현 종류
            - 방향 그래프
                
                ![방향 그래프 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/f9e15ed2-4e75-4c20-8d21-af929cde7c02/Untitled.png)
                
                방향 그래프 
                
            - 무방향 그래프
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/2aab6d7c-6eeb-4f49-b0f0-51e2dda6942e/Untitled.png)
                
            
            무방향이기 때문에 노드 i → 노드 j로 가는 간선이 있다는 말은 노드 j → 노드 i로 가는 간선도 존재한다는 의미
            ➡️ 인접 행렬이 대각성분(adj[i][j]에서 i와 j가 같은 원소들)을 기준으로 대칭
            
        - 장점
            - 구현이 비교적 간단하다
            - 2차원 배열 상에 그래프의 정보가 모두 담겨있기 때문에,
                1. 두 정점을 연결하는 간선을 조회할 때 O(1)의 시간복잡도
                2. 정점 i의 차수를 구할 때 (인접행렬 M의 i번째 항을 모두 더하면 되므로) O(n)의 시간복잡도
        - 단점
            - 간선의 수와 무관하게 항상 n^2 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다
            - 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n^2)의 시간복잡도 소요
            
            ➡️ 노드의 개수에 비해 간선의 개수가 훨씬 적은 그래프일 경우 문제 발생
            
    
    - **인접 리스트 Adjacency List**
        
        그래프의 연결관계를 리스트로 나타내는 방식
        
        adj[i] : 노드 i에 연결된 요소들을 원소로 갖는 리스트
        
        (만약 간선에 가중치가 있다면 dict<int, int>adj[]를 통해 구현 가능 - first에는 노드의 번호, second에는 간선의 가중치 저장)
        
        !https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F5f21a135-da40-40a7-baaa-637c6ae956a9%2Fimage.png
        
        - 구현 종류
            - 방향 그래프
                
                ![방향 그래프 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/4dc38ccb-534b-4ceb-813a-cc8c4194ba38/Untitled.png)
                
                방향 그래프 
                
            - 무방향 그래프
                
                ![무방향 그래프 ](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/d523fca9-2ff6-4fee-86cb-cdf9b6c589be/Untitled.png)
                
                무방향 그래프 
                
        
        - 장점
            - 인접 행렬과 달리 실제로 연결된 노드들에 대한 정보만 관리하므로 리스트의 원소 개수 합이 간선의 개수와 같다 → 메모리 사용 측면에서 보다 효율적이다
            - 그래프의 각 노드에 연결된 모든 노드들을 방문해야 하는 경우 전체 간선의 개수만큼만 확인할 수 있으므로 O(E)의 시간복잡도를 가진다
        - 단점
            - 구현이 비교적 어렵다
            - 두 정점을 연결하는 간선을 조회하거나, 정점의 차수를 알기 위해서는 정점의 인접리스트를 탐색해야 하므로 정점의 차수만큼의 O(degree(v)) 시간복잡도 소요

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/ff1a2962-1634-4ded-b43e-520ec2d445cc/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/24ad92f3-451d-444a-b90a-4b794c3b436d/Untitled.png)

- 탐색 방법
    
    ![img.gif](https://prod-files-secure.s3.us-west-2.amazonaws.com/12d73fc0-8c8a-4e99-991e-f2e1a4ab98e7/9c825686-4712-4ba9-bc40-f300815fab03/img.gif)
    
    - BFS 너비 우선 탐색
        
        정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고 찾고자 하는 정점을 만날 때 까지 반복한다. 
        
        일반적으로 `Queue` 를 사용하여 구현한다.
        
    - DFS 깊이 우선 탐색
        
        루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
        
        재귀함수를 통해서 구현하기도 하고 혹은 `Stack` 을 사용해 구현하기도 한다.
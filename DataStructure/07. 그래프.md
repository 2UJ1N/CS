## 비선형 자료구조

일렬로 나열되지 않고, 자료 순서나 관계가 복잡한 구조 

## 그래프 graph

단순히 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조 

→ 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조

![1](https://github.com/2UJ1N/CS/assets/83401978/bcd0fd35-4c20-4fbf-9ba8-9024a584babb)

- 구성요소
    - **정점 Vertex**
        
        = 노드(node), 데이터가 저장되는 그래프 기본 원소
        
    - **간선 Edge**
        
        = 링크(link), 정점간의 관계를 나타냄
        
    - **차수 Degree** : 정점 하나에 연결된 간선의 수
        - 진출 차수 out-degree : 정점 하나를 기준으로 나가는 간선
        - 진입 차수 in-degree : 정점을 기준으로 들어오는 간선
    - 인접 정점 adjacent vertex : 간선에 의해 연결된 정점
    - 단순 경로 simple path : 동일한 간선을 지나지 않는 경로
    - 가중치 : 간선과 정점 사이에 드는 비용

- 종류
    - 무방향 그래프
        
        ![2](https://github.com/2UJ1N/CS/assets/83401978/84ca0687-b9b2-472e-8c43-e4a807f79daf)
        
    - 방향 그래프
        
        ![3](https://github.com/2UJ1N/CS/assets/83401978/173030a7-26d0-40fe-b6dd-75d8e4cb21db)
        
    - 가중치 그래프
        
        ![4](https://github.com/2UJ1N/CS/assets/83401978/20d0f49f-f563-4fa8-b280-eb902fac96c7)
        
    - 완전 그래프
        
        : 정점에 대해 가능한 모든 간선을 가진 그래프
        
        ![5](https://github.com/2UJ1N/CS/assets/83401978/56bcbcfd-2360-412a-b04c-df6c955d2000)
        
    - 연결 그래프
        
        : 임의의 두 정점 사이에 경로가 항상 존재하는 그래프
        
        ![6](https://github.com/2UJ1N/CS/assets/83401978/5575640f-1d0e-4040-9620-e6f39a7907fc)
        
    - 루프 : 한 정점에서 시작해 같은 정점으로 들어오는 간선
        
        ![7](https://github.com/2UJ1N/CS/assets/83401978/bf5b7a60-c0d1-44dd-9a41-6e2e8c17c462)
        
        루프 
        
        - 단순 그래프 : 두 정점 사이에 간선이 1개 이하이고 루프가 존재하지 않는 그래프
    - 사이클 : 임의의 한 점에서 출발해 자기 자신으로 돌아올 수 있는 경로
        - 순환 그래프 : 그래프 안에 사이클이 하나라도 있는 그래프
            
            ![8](https://github.com/2UJ1N/CS/assets/83401978/7c4ac53c-d438-403f-9e76-47c5352c21bc)
            
            순환 그래프 
            
        - 비순환 그래프 : 그래프 안에 사이클이 하나도 없는 그래프

- 그래프 구현 방법
    1. 인접 행렬
    2. 인접 리스트
    
    - **인접 행렬 Adjacency Matrix**
        
        : 그래프의 연결 관계를 2차원 배열로 나타내는 방식
        인접 행렬 adj[i][j] 는 노드 i에서 노드 j로 가는 간선이 있으면 1, 아니면 0
        (간선에 가중치가 있는 그래프라면 1 대신 가중치의 값으로 표현)
        
        ![9](https://github.com/2UJ1N/CS/assets/83401978/b0c3a3d4-9b15-4e70-bb4a-baa4a69158af)
        
        - 구현 종류
            - 방향 그래프
                
                ![10](https://github.com/2UJ1N/CS/assets/83401978/16ba657c-3aab-4b2f-ae39-cd5af579f8b5)
                
                방향 그래프 
                
            - 무방향 그래프
                
                ![11](https://github.com/2UJ1N/CS/assets/83401978/424b1cfe-46c8-4d19-87f2-2c64479ef4bb)
                
            
            무방향이기 때문에 노드 i → 노드 j로 가는 간선이 있다는 말은 노드 j → 노드 i로 가는 간선도 존재한다는 의미
            ➡️ 인접 행렬이 대각성분(adj[i][j]에서 i와 j가 같은 원소들)을 기준으로 대칭
            
        - 장점
            - 구현이 비교적 간단하다
            - 2차원 배열 상에 그래프의 정보가 모두 담겨있기 때문에,
                1. 두 정점을 연결하는 간선을 조회할 때 O(1)의 시간복잡도
                2. 정점 i의 차수를 구할 때 (인접행렬 M의 i번째 항을 모두 더하면 되므로) O(n)의 시간복잡도
        - 단점
            - 간선의 수와 무관하게 항상 n^2 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다
            - 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n^2)의 시간복잡도 소요
            
            ➡️ 노드의 개수에 비해 간선의 개수가 훨씬 적은 그래프일 경우 문제 발생
            
    
    - **인접 리스트 Adjacency List**
        
        그래프의 연결관계를 리스트로 나타내는 방식
        
        adj[i] : 노드 i에 연결된 요소들을 원소로 갖는 리스트
        
        (만약 간선에 가중치가 있다면 dict<int, int>adj[]를 통해 구현 가능 - first에는 노드의 번호, second에는 간선의 가중치 저장)
        
        ![12](https://github.com/2UJ1N/CS/assets/83401978/da5f8b50-8ba9-4e31-9197-f6b8a3954e34)
        
        - 구현 종류
            - 방향 그래프
                
                ![13](https://github.com/2UJ1N/CS/assets/83401978/a41aed1e-8b84-475d-8223-491d01eb94d6)
                
                방향 그래프 
                
            - 무방향 그래프
                
                ![14](https://github.com/2UJ1N/CS/assets/83401978/5b69637a-e796-4891-ad9b-a2a1781b8f3e)
                
                무방향 그래프 
                
        
        - 장점
            - 인접 행렬과 달리 실제로 연결된 노드들에 대한 정보만 관리하므로 리스트의 원소 개수 합이 간선의 개수와 같다 → 메모리 사용 측면에서 보다 효율적이다
            - 그래프의 각 노드에 연결된 모든 노드들을 방문해야 하는 경우 전체 간선의 개수만큼만 확인할 수 있으므로 O(E)의 시간복잡도를 가진다
        - 단점
            - 구현이 비교적 어렵다
            - 두 정점을 연결하는 간선을 조회하거나, 정점의 차수를 알기 위해서는 정점의 인접리스트를 탐색해야 하므로 정점의 차수만큼의 O(degree(v)) 시간복잡도 소요

![15](https://github.com/2UJ1N/CS/assets/83401978/88d64b3a-ac7b-4830-9760-58ae311cb9af)

![16](https://github.com/2UJ1N/CS/assets/83401978/f603c925-6550-4e6e-895e-d456b1d47523)

- 탐색 방법
    
    ![17](https://github.com/2UJ1N/CS/assets/83401978/9c85d650-9d08-4f27-ae2e-f68b857c2183)
    
    - BFS 너비 우선 탐색
        
        정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고 찾고자 하는 정점을 만날 때 까지 반복한다. 
        
        일반적으로 `Queue` 를 사용하여 구현한다.
        
    - DFS 깊이 우선 탐색
        
        루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
        
        재귀함수를 통해서 구현하기도 하고 혹은 `Stack` 을 사용해 구현하기도 한다.

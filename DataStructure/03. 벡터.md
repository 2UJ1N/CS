# 벡터

## 선형 자료구조

요소가 일렬로 나열되어 있는 자료구조

## 벡터 Vector

동적 요소를 할당할 수 있는 동적 배열

다양한 데이터들이 배열의 형태로 저장된 연속체

![9](https://github.com/2UJ1N/CS/assets/83401978/c1e41893-eb6d-4a49-96bc-d67dc2f021c0)

- 사용 예시
    - 저장할 데이터 개수가 가변적인 경우
    - 중간 위치의 데이터 삽입/삭제 연산이 없는 경우
        
        (벡터는 배열처럼 데이터를 순차적으로 저장하므로 중간 위치에 데이터를 삽입/삭제한다면 배열과 같은 문제가 발생한다)
        
    - 저장할 데이터의 개수가 적은 경우
    - 저장할 데이터의 개수가 많다면 빈번한 검색이 필요치 않은 경우
        - 데이터를 순차적으로 저장하기 때문에 데이터의 양에 따라 검색 속도가 달라지므로
    - 데이터의 위치를 알고 있어 빠른 접근을 원하는 경우

- 벡터 연산
    - 데이터 삽입
        - `insert` 벡터의 처음/중간 위치에 요소를 더한다
        - `push_back()` 벡터의 뒤부터 요소를 더한다
    
    ![10](https://github.com/2UJ1N/CS/assets/83401978/a4964a81-c6f0-41d9-8dd1-a1a7fb793821)
    
    - 삭제
        - `erase` 벡터의 처음/중간 위치의 요소를 삭제한다
        - `pop_back()` 벡터의 마지막 요소를 삭제한다
    - `clear()` 배열 초기화
    
    ![11](https://github.com/2UJ1N/CS/assets/83401978/72cc83f4-e6be-42b8-bf4d-ff85aa928cc4)
    
    ![12](https://github.com/2UJ1N/CS/assets/83401978/b83354c8-2e71-425b-8ff3-d2afb177b1e5)
    
    ![13](https://github.com/2UJ1N/CS/assets/83401978/03ec8edb-6884-412b-82dd-e51f3a91b8f0)

- 시간복잡도
    - 삽입/삭제
        - O(n) : 해당 인덱스의 값을 삽입/삭제한 동시에 이후의 데이터를 움직여야 하기 때문이다
            
            (원형 배열 기반으로 구현될 경우에는 O(1)
            
    - 검색 O(1) : 인덱스로 모든 데이터에 접근할 수 있다

---
### ✏️ 배열과 벡터 비교

**장점**
- **배열** : index를 통한 빠른 접근 가능
- **벡터** : 배열보다 메모리 공간을 더 차지한다
            메모리가 동적으로 달라질 수 있다

**단점**
- **배열** : 삽입/삭제에 시간이 오래 걸린다
            크기가 고정적이다
            배열 중간에 있는 데이터가 삭제되면 공간 낭비가 발생한다
- **벡터** : 포인터를 통한 빠른 접근 가능 - 속도 측면에서는 배열보다 느리다

</aside>
